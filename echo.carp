(Project.config "title" "echo")

;; TODO: Make this a safe function
(defn get-arg [n]
      (Maybe.unsafe-from (StaticArray.nth &System.args n)))

(defn parse-number [string-ref string-ref-length begin-index max-length digit? fold]
      (let [digits []]
	(do
	  ;; Collect digits
	  (while true
		 (let [i (Array.length &digits)]
		   (do
		     (unless (< i max-length)
		       (break))
		     (unless (< (+ i begin-index) string-ref-length)
		       (break))
		     (let [item (String.char-at string-ref (+ i begin-index))]
		       (if (digit? item)
			 (Array.push-back! &digits item)
			 (break))))))

	  (if (Array.empty? &digits)
	    (Maybe.Nothing)
	    (Maybe.Just (let [amount-of-items-processed (Array.length &digits)
			      number (fold &digits)]
			  (Pair.init number amount-of-items-processed)))))))

(defn hex-digit? [c]
      (or
       (and
	 (>= c \0)
	 (<= c \9))
       (or
	 (and
	   (>= c \a)
	   (<= c \f))
	 (and
	   (>= c \A)
	   (<= c \F)))))

(defn char-to-hex-nibble [c]
      (cond
	(and
	  (>= c \0)
	  (<= c \9)) (- (Char.to-int c) (Char.to-int \0))
	(and
	  (>= c \A)
	  (<= c \F)) (+ 10 (- (Char.to-int c) (Char.to-int \A)))
	(and
	  (>= c \a)
	  (<= c \f)) (+ 10 (- (Char.to-int c) (Char.to-int \a)))
	0)) ;; TODO Use Maybe?

(defn fold-to-hex [arr] \A) ;; TODO: Implement

(defn oct-digit? [c] (and (>= c \0) (<= c \8)))

(defn fold-to-oct [arr] \A) ;; TODO: Implement

(defn escape-string [string-ref]
      (let [escaped-string (String.allocate (String.length string-ref) (Char.from-int 1)) ;; Can't put 0 because strlen is used in assertions
	    escaped-string-length 0
	    string-ref-index 0
	    string-ref-length (String.length string-ref)]
	(do
	  (while (< string-ref-index string-ref-length)
		 (let [current-char (String.char-at string-ref string-ref-index)
		       next-char-index (inc string-ref-index)
		       escaped-string-addition current-char
		       string-ref-index-addition 1]
		   (do
		     (when (and (= current-char \\) (< next-char-index string-ref-length))
		       ;; Escape sequence
		       (let [next-char (String.char-at string-ref next-char-index)]
			 (cond

			   ;; Produce no further output
			   (= \c next-char) (do
					      (IO.print &(String.slice &escaped-string 0 escaped-string-length))
					      (System.exit 0))

			   (= \x next-char) (let [parse-result (parse-number
						      string-ref
						      string-ref-length
						      (inc next-char-index)
						      2
						      hex-digit?
						      fold-to-hex)]
					      (when (Maybe.just? &parse-result)
						(let [number-and-addition (Maybe.unsafe-from parse-result)]
						  (do
						    (set! escaped-string-addition (Char.copy (Pair.a &number-and-addition)))
						    (set! string-ref-index-addition (+ 2 (Int.copy (Pair.b &number-and-addition))))))))

			   (= \0 next-char) (let [parse-result (parse-number
						      string-ref
						      string-ref-length
						      (inc next-char-index)
						      3
						      oct-digit?
						      fold-to-oct)]
					      (when (Maybe.just? &parse-result)
						(let [number-and-addition (Maybe.unsafe-from parse-result)]
						  (do
						    (set! escaped-string-addition (Char.copy (Pair.a &number-and-addition)))
						    (set! string-ref-index-addition (+ 2 (Int.copy (Pair.b &number-and-addition))))))))

			   ;; Single character
			   (let [replacement-char (cond
						    (= \a next-char) (Maybe.Just (Char.from-int 7))
						    (= \b next-char) (Maybe.Just (Char.from-int 8))
						    (= \t next-char) (Maybe.Just (Char.from-int 9))
						    (= \n next-char) (Maybe.Just (Char.from-int 10))
						    (= \v next-char) (Maybe.Just (Char.from-int 11))
						    (= \f next-char) (Maybe.Just (Char.from-int 12))
						    (= \r next-char) (Maybe.Just (Char.from-int 13))
						    (Maybe.Nothing))]
			     ;; TODO: Don't use Maybe
			     (when (Maybe.just? &replacement-char)
			       (do
				 (set! escaped-string-addition (Maybe.unsafe-from replacement-char))
				 (set! string-ref-index-addition 2)))))))

		     (String.string-set! &escaped-string escaped-string-length escaped-string-addition)
		     (set! string-ref-index (+ string-ref-index string-ref-index-addition))
		     (set! escaped-string-length (inc escaped-string-length)))))

	  (String.slice &escaped-string 0 escaped-string-length))))

(defn echo-arguments [first-argument-index
		      last-argument-index
		      echo-newline
		      escape-arguments]
      (do
	(let [counter first-argument-index]
	  (while (< counter last-argument-index)
		 (do
		   (if escape-arguments
		     (IO.print &(escape-string &(get-arg counter)))
		     (IO.print &(get-arg counter)))
		   (set! counter (inc counter))
		   (when (>= counter last-argument-index)
		     (break))
		   (IO.print " "))))
	(when echo-newline
	  (IO.print "\n"))))

(defn main []
      (let [argc (StaticArray.length &System.args)
	    add-newline true
	    escape-characters false
	    first-non-flag-argument-index 0]
	(do

	  ;; Find flags
	  (let [argument-index 1]
	    (do
	      (while (< argument-index argc)
		     (do
		       (cond
			 ;; TODO: Support -en -ne --help etc
			 (= &(get-arg argument-index) "-e") (set! escape-characters true)
			 (= &(get-arg argument-index) "-E") (set! escape-characters false)
			 (= &(get-arg argument-index) "-n") (set! add-newline false)
			 (break))
		       (set! argument-index (inc argument-index))))
	      (set! first-non-flag-argument-index argument-index)))

	  (echo-arguments
	    first-non-flag-argument-index
	    argc
	    add-newline
	    escape-characters))))
