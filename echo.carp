(Project.config "title" "echo")

(defn escape-string [string-ref]
      (let [escaped-string (String.allocate (String.length string-ref) (Char.from-int 1)) ;; Can't put 0 because strlen is used in assertions
	    escaped-string-length 0
	    string-ref-index 0
	    string-ref-length (String.length string-ref)]
	(do
	  (while (< string-ref-index string-ref-length)
		 (let [current-char (String.char-at string-ref string-ref-index)
		       next-char-index (inc string-ref-index)
		       escaped-string-addition current-char
		       string-ref-index-addition 1]
		   (do
		     (when (and (= current-char \\) (< next-char-index string-ref-length))
		       ;; Escape sequence
		       (let [next-char (String.char-at string-ref next-char-index)]
			 (cond

			   ;; Produce no further output
			   (= \c next-char) (do
					      (IO.print &(String.slice &escaped-string 0 escaped-string-length))
					      (System.exit 0))

			   ;; TODO (= \0 next-char) ()
			   ;; TODO (= \x next-char) ()

			   ;; Single character
			   (let [replacement-char (cond
						    (= \a next-char) (Maybe.Just (Char.from-int 7))
						    (= \b next-char) (Maybe.Just (Char.from-int 8))
						    (= \t next-char) (Maybe.Just (Char.from-int 9))
						    (= \n next-char) (Maybe.Just (Char.from-int 10))
						    (= \v next-char) (Maybe.Just (Char.from-int 11))
						    (= \f next-char) (Maybe.Just (Char.from-int 12))
						    (= \r next-char) (Maybe.Just (Char.from-int 13))
						    (Maybe.Nothing))]
			     ;; TODO: Don't use Maybe
			     (when (Maybe.just? &replacement-char)
			       (do
				 (set! escaped-string-addition (Maybe.unsafe-from replacement-char))
				 (set! string-ref-index-addition 2)))))))

		     (String.string-set! &escaped-string escaped-string-length escaped-string-addition)
		     (set! string-ref-index (+ string-ref-index string-ref-index-addition))
		     (set! escaped-string-length (inc escaped-string-length)))))

	  (String.slice &escaped-string 0 escaped-string-length))))

(defn echo-arguments [first-argument-index
		      last-argument-index
		      echo-newline
		      escape-arguments]
      (do
	(let [counter first-argument-index]
	  (while (< counter last-argument-index)
		 (do
		   (if escape-arguments
		     (IO.print &(escape-string (System.get-arg counter)))
		     (IO.print (System.get-arg counter)))
		   (set! counter (inc counter))
		   (when (>= counter last-argument-index)
		     (break))
		   (IO.print " "))))
	(when echo-newline
	  (IO.print "\n"))))

(defn main []
      (let [argc (System.get-args-len)
	    add-newline true
	    escape-characters false
	    first-non-flag-argument-index 0]
	(do

	  ;; Find flags
	  (let [argument-index 1]
	    (do
	      (while (< argument-index argc)
		     (do
		       (cond
			 ;; TODO: Support -en -ne --help etc
			 (= (System.get-arg argument-index) "-e") (set! escape-characters true)
			 (= (System.get-arg argument-index) "-E") (set! escape-characters false)
			 (= (System.get-arg argument-index) "-n") (set! add-newline false)
			 (break))
		       (set! argument-index (inc argument-index))))
	      (set! first-non-flag-argument-index argument-index)))

	  (echo-arguments
	    first-non-flag-argument-index
	    argc
	    add-newline
	    escape-characters))))
